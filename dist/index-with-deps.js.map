{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e990e667dcfc02170b5e","webpack:///./src/index.js","webpack:///./~/skatejs/umd/index.js","webpack:///./~/@skatejs/renderer-preact/umd/index.js","webpack:///./~/preact/dist/preact.js"],"names":["BigNumber","name","props","string","customElements","define"],"mappings":"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AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;;AAEL;AACA,IAAG;AACH;;AAEA;AACA;;AAEA,gCAA+B,eAAe;AAC9C;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,4BAA2B;AAC3B;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEnjB,oDAAmD,0CAA0C,0DAA0D,EAAE;;AAEzJ,oDAAmD,aAAa,uFAAuF,EAAE,uFAAuF;;AAEhP,6CAA4C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE9e,4BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,IAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEnjB,oDAAmD,0CAA0C,0DAA0D,EAAE;;AAEzJ,oDAAmD,aAAa,uFAAuF,EAAE,uFAAuF;;AAEhP,6CAA4C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE9e;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA8C,cAAc;;AAE5D,EAAC;AACD;;;;;;;ACvoBA;AACA;AACA;AACA;AACA,EAAC,2BAA2B;;AAE5B,oDAAmD,gBAAgB,sBAAsB,OAAO,2BAA2B,0BAA0B,yDAAyD,2BAA2B,EAAE,EAAE,EAAE,eAAe;;AAE9P,iCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,sDAAqD,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,wCAAwC,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE;;AAExe,kDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,kDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,2CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,2BAA0B,+FAA+F,mCAAmC;AAC5J;AACA,MAAK;;AAEL;AACA,IAAG;AACH,EAAC;;AAED;;AAEA,EAAC;AACD;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA,mCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA,uGAAsG,KAAK,wBAAwB;AACnI;AACA,uFAAsF,0DAA0D;AAChJ,8EAA6E,4DAA4D;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wHAAuH;AACvH;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,UAAS,mEAAmE;AAC5E;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb,wCAAuC;AACvC,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,mIAAkI,iCAAiC,6HAA6H;AAChS;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,KAAK;AAC3D;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,iGAAgG;AAChG,uCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,wCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,oDAAoD,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA6F,iDAAiD;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,4CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAAyE;AACzE;AACA;AACA;AACA;AACA,wJAAuJ;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAA8D;AAC9D,EAAC;AACD,mC","file":"dist/index-with-deps.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"biggerNumbers\"] = factory();\n\telse\n\t\troot[\"biggerNumbers\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e990e667dcfc02170b5e","/** @jsx h */\n// Main file for bigger-numbers component.\n\n// Import Skate.js for component building.\nimport { props, withComponent } from \"skatejs\";\n\n// Import withPreact as the renderer.\nimport withPreact from \"@skatejs/renderer-preact\";\n\n// Import Preact.\nimport { h } from \"preact\";\n\nclass BigNumber extends withComponent(withPreact()) {\n  static props = {\n    name: props.string\n  };\n  render({ name }) {\n    return <div>{name}</div>;\n  }\n}\n\ncustomElements.define(\"big-number\", BigNumber);\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.skate = {})));\n}(this, (function (exports) { 'use strict';\n\nfunction define(Ctor) {\n  var registry = customElements;\n  var is = Ctor.is;\n  if (!registry.get(is)) {\n    registry.define(is, Ctor);\n  }\n  return Ctor;\n}\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar defs = {\n  bubbles: true,\n  cancelable: true,\n  composed: false\n};\n\nfunction emit(elem, name, opts) {\n  opts = _extends({}, defs, opts);\n  var e = void 0;\n  if ('composed' in CustomEvent.prototype) {\n    e = new CustomEvent(name, opts);\n  } else {\n    e = document.createEvent('CustomEvent');\n    e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n    Object.defineProperty(e, 'composed', { value: opts.composed });\n  }\n  return elem.dispatchEvent(e);\n}\n\nfunction getValue(elem) {\n  var checked = elem.checked,\n      type = elem.type,\n      value = elem.value;\n\n  if (type === 'checkbox' || type === 'radio') {\n    return checked ? value || true : false;\n  }\n  return value;\n}\n\nfunction link(elem, target) {\n  return function (e) {\n    // TODO revisit once all browsers have native support.\n    //\n    // We fallback to checking the composed path. Unfortunately this behaviour\n    // is difficult to impossible to reproduce as it seems to be a possible\n    // quirk in the shadydom polyfill that incorrectly returns null for the\n    var localTarget = e.target || e.composedPath && e.composedPath()[0];\n    var value = getValue(localTarget);\n    var localTargetName = target || localTarget.name || 'value';\n\n    if (localTargetName.indexOf('.') > -1) {\n      var parts = localTargetName.split('.');\n      var firstPart = parts[0];\n      var propName = parts.pop();\n      var obj = parts.reduce(function (prev, curr) {\n        return prev[curr];\n      }, elem);\n\n      obj[propName || localTarget.name] = value;\n      elem[firstPart] = elem[firstPart];\n    } else {\n      elem[localTargetName] = value;\n    }\n  };\n}\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar withChildren = function withChildren() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return function (_Base) {\n    _inherits(_class, _Base);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    _createClass(_class, [{\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        var _this2 = this;\n\n        if (_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), \"connectedCallback\", this)) {\n          _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), \"connectedCallback\", this).call(this);\n        }\n        if (this.childrenChangedCallback) {\n          var mo = new MutationObserver(function () {\n            return _this2.childrenChangedCallback();\n          });\n          mo.observe(this, { childList: true });\n          this.childrenChangedCallback();\n        }\n      }\n    }]);\n\n    return _class;\n  }(Base);\n};\n\nvar _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Mo = typeof MutationObserver === 'function' ? MutationObserver : function () {\n  function _class2(func) {\n    _classCallCheck$2(this, _class2);\n\n    this.func = func;\n  }\n\n  _createClass$2(_class2, [{\n    key: 'observe',\n    value: function observe(node) {\n      var func = this.func;\n\n      var prop = {\n        set: function set() {\n          if (typeof Promise === 'undefined') {\n            setTimeout(func);\n          } else {\n            new Promise(function (resolve) {\n              return resolve();\n            }).then(func);\n          }\n        }\n      };\n      Object.defineProperty(node, 'textContent', prop);\n    }\n  }]);\n\n  return _class2;\n}();\n\nfunction dashCase(str) {\n  return str.split(/([_A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    two = two === '_' ? '' : two;\n    return '' + one + dash + two.toLowerCase();\n  });\n}\n\nfunction debounce(cbFunc) {\n  var scheduled = false;\n  var i = 0;\n  var elem = document.createElement('span');\n  var observer = new Mo(function () {\n    cbFunc();\n    scheduled = false;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = '' + i;\n      i += 1;\n    }\n  };\n}\n\nvar empty = function empty(val) {\n  return val == null;\n};\n\nfunction keys(obj) {\n  obj = obj || {};\n  var names = Object.getOwnPropertyNames(obj);\n  return Object.getOwnPropertySymbols ? names.concat(Object.getOwnPropertySymbols(obj)) : names;\n}\n\nfunction sym(description) {\n  return typeof Symbol === 'function' ? Symbol(description ? String(description) : undefined) : uniqueId(description);\n}\n\nfunction uniqueId(description) {\n  return (description ? String(description) : '') + 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\nvar _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction normaliseAttributeDefinition(name, prop) {\n  var attribute = prop.attribute;\n\n  var obj = (typeof attribute === \"undefined\" ? \"undefined\" : _typeof(attribute)) === \"object\" ? _extends$1({}, attribute) : {\n    source: attribute,\n    target: attribute\n  };\n  if (obj.source === true) {\n    obj.source = dashCase(name);\n  }\n  if (obj.target === true) {\n    obj.target = dashCase(name);\n  }\n  return obj;\n}\n\nfunction normalisePropertyDefinition(name, prop) {\n  var coerce = prop.coerce,\n      def = prop.default,\n      deserialize = prop.deserialize,\n      serialize = prop.serialize;\n\n  return {\n    attribute: normaliseAttributeDefinition(name, prop),\n    coerce: coerce || function (v) {\n      return v;\n    },\n    default: def,\n    deserialize: deserialize || function (v) {\n      return v;\n    },\n    serialize: serialize || function (v) {\n      return v;\n    }\n  };\n}\n\nfunction syncAttributeToProperty(elem, name, value) {\n  if (elem._syncingPropertyToAttribute) {\n    return;\n  }\n  var propDefs = elem.constructor.props;\n  for (var propName in propDefs) {\n    var _propDefs$propName = propDefs[propName],\n        source = _propDefs$propName.attribute.source,\n        deserialize = _propDefs$propName.deserialize;\n\n    if (source === name) {\n      elem._syncingAttributeToProperty = propName;\n      elem[propName] = value == null ? value : deserialize(value);\n      elem._syncingAttributeToProperty = null;\n    }\n  }\n}\n\nfunction syncPropertyToAttribute(elem, target, serialize, val) {\n  if (target && elem._syncingAttributeToProperty !== target) {\n    var serialized = serialize(val);\n    elem._syncingPropertyToAttribute = true;\n    if (serialized == null) {\n      elem.removeAttribute(target);\n    } else {\n      elem.setAttribute(target, serialized);\n    }\n    elem._syncingPropertyToAttribute = false;\n  }\n}\n\nvar _get$1 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits$1(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction prop(definition) {\n  var propertyDefinition = definition || {};\n\n  // Allows decorators, or imperative definitions.\n  var func = function func(_ref, name) {\n    var constructor = _ref.constructor;\n\n    var normalised = normalisePropertyDefinition(name, propertyDefinition);\n    var _value = sym(name);\n\n    // Ensure that we can cache properties. We have to do this so the _props object literal doesn't modify parent\n    // classes or share the instance anywhere where it's not intended to be shared explicitly in userland code.\n    if (!constructor.hasOwnProperty('_props')) {\n      constructor._props = {};\n    }\n\n    // Cache the value so we can reference when syncing the attribute to the property.\n    constructor._props[name] = normalised;\n\n    if (normalised.attribute.source) {\n      constructor.observedAttributes = normalised.attribute.source;\n    }\n\n    Object.defineProperty(constructor.prototype, name, {\n      configurable: true,\n      get: function get() {\n        var val = this[_value];\n        return val == null ? normalised.default : val;\n      },\n      set: function set(val) {\n        this[_value] = normalised.coerce(val);\n        syncPropertyToAttribute(this, normalised.attribute.target, normalised.serialize, val);\n        this._updateDebounced();\n      }\n    });\n  };\n\n  // Allows easy extension of pre-defined props { ...prop(), ...{} }.\n  Object.keys(propertyDefinition).forEach(function (key) {\n    return func[key] = propertyDefinition[key];\n  });\n\n  return func;\n}\n\nvar withProps = function withProps() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return function (_Base) {\n    _inherits$1(_class2, _Base);\n\n    _createClass$1(_class2, [{\n      key: 'props',\n      get: function get() {\n        var _this2 = this;\n\n        return keys(this.constructor.props).reduce(function (prev, curr) {\n          prev[curr] = _this2[curr];\n          return prev;\n        }, {});\n      },\n      set: function set(props) {\n        var _this3 = this;\n\n        var ctorProps = this.constructor.props;\n        keys(props).forEach(function (k) {\n          return k in ctorProps && (_this3[k] = props[k]);\n        });\n      }\n    }], [{\n      key: 'observedAttributes',\n      get: function get() {\n        return this._observedAttributes || [];\n      },\n      set: function set(attrs) {\n        if (!this.hasOwnProperty('_observedAttributes')) {\n          this._observedAttributes = [];\n        }\n        this._observedAttributes = this.observedAttributes.concat(attrs);\n      }\n    }, {\n      key: 'props',\n      get: function get() {\n        return this._props || {};\n      },\n      set: function set(props) {\n        var _this4 = this;\n\n        keys(props).forEach(function (name) {\n          var func = props[name];\n          if (typeof func !== 'function') func = prop(func);\n          func({ constructor: _this4 }, name);\n        });\n      }\n    }]);\n\n    function _class2() {\n      _classCallCheck$1(this, _class2);\n\n      var _this = _possibleConstructorReturn$1(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this));\n\n      _this._updateCallback = function () {\n        if (_this._updating || !_this._connected) {\n          return;\n        }\n\n        // Flag as rendering. This prevents anything from trying to render - or\n        // queueing a render - while there is a pending render.\n        _this._updating = true;\n\n        // Prev / next props for prop lifecycle callbacks.\n        var prev = _this._prevProps;\n        var next = _this._prevProps = _this.props;\n\n        // Always call set, but only call changed if the props updated.\n        if (_this.propsSetCallback) {\n          _this.propsSetCallback(next, prev);\n        }\n\n        // We only need to check if props have updated if we need to call the\n        // changed callback.\n        if (_this.propsChangedCallback && _this.propsUpdatedCallback(next, prev)) {\n          _this.propsChangedCallback(next, prev);\n        }\n\n        _this._updating = false;\n      };\n\n      if (_this._constructed) return _possibleConstructorReturn$1(_this);\n      _this._constructed = true;\n      _this._updateDebounced = debounce(_this._updateCallback);\n      return _this;\n    }\n\n    _createClass$1(_class2, [{\n      key: 'connectedCallback',\n      value: function connectedCallback() {\n        if (this._connected) return;\n        this._connected = true;\n        // $FlowFixMe - HTMLElement doesn't implement connectedCallback.\n        if (_get$1(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'connectedCallback', this)) _get$1(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'connectedCallback', this).call(this);\n        this._updateDebounced();\n      }\n    }, {\n      key: 'disconnectedCallback',\n      value: function disconnectedCallback() {\n        if (!this._connected) return;\n        this._connected = false;\n        // $FlowFixMe - HTMLElement doesn't implement disconnectedCallback.\n        if (_get$1(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'disconnectedCallback', this)) _get$1(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'disconnectedCallback', this).call(this);\n      }\n\n      // Called to see if the props changed.\n\n    }, {\n      key: 'propsUpdatedCallback',\n      value: function propsUpdatedCallback(next, prev) {\n        return !prev || keys(prev).some(function (k) {\n          return prev[k] !== next[k];\n        });\n      }\n    }, {\n      key: 'attributeChangedCallback',\n      value: function attributeChangedCallback(name, oldValue, newValue) {\n        if (_get$1(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'attributeChangedCallback', this))\n          // $FlowFixMe - HTMLElement doesn't implement attributeChangedCallback.\n          _get$1(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'attributeChangedCallback', this).call(this, name, oldValue, newValue);\n        syncAttributeToProperty(this, name, newValue);\n      }\n\n      // Invokes the complete render lifecycle.\n\n    }]);\n\n    return _class2;\n  }(Base);\n};\n\nvar parse = JSON.parse;\nvar stringify = JSON.stringify;\n\nvar attribute = Object.freeze({ source: true });\nvar zeroOrNumber = function zeroOrNumber(val) {\n  return empty(val) ? 0 : Number(val);\n};\n\nvar any = prop({\n  attribute: attribute\n});\n\nvar array = prop({\n  attribute: attribute,\n  coerce: function coerce(val) {\n    return Array.isArray(val) ? val : empty(val) ? null : [val];\n  },\n  default: Object.freeze([]),\n  deserialize: parse,\n  serialize: stringify\n});\n\nvar boolean = prop({\n  attribute: attribute,\n  coerce: Boolean,\n  default: false,\n  deserialize: function deserialize(val) {\n    return !empty(val);\n  },\n  serialize: function serialize(val) {\n    return val ? '' : null;\n  }\n});\n\nvar number = prop({\n  attribute: attribute,\n  default: 0,\n  coerce: zeroOrNumber,\n  deserialize: zeroOrNumber,\n  serialize: function serialize(val) {\n    return empty(val) ? null : String(Number(val));\n  }\n});\n\nvar object = prop({\n  attribute: attribute,\n  default: Object.freeze({}),\n  deserialize: parse,\n  serialize: stringify\n});\n\nvar string = prop({\n  attribute: attribute,\n  default: '',\n  coerce: String,\n  serialize: function serialize(val) {\n    return empty(val) ? null : String(val);\n  }\n});\n\nvar props = {\n  any: any,\n  array: array,\n  boolean: boolean,\n  number: number,\n  object: object,\n  string: string\n};\n\nvar _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits$2(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar attachShadowOptions = { mode: 'open' };\n\nfunction attachShadow(elem) {\n  return elem.attachShadow ? elem.attachShadow(attachShadowOptions) : elem;\n}\n\nvar withRenderer = function withRenderer() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return function (_Base) {\n    _inherits$2(_class2, _Base);\n\n    function _class2() {\n      _classCallCheck$3(this, _class2);\n\n      return _possibleConstructorReturn$2(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));\n    }\n\n    _createClass$3(_class2, [{\n      key: 'propsChangedCallback',\n      value: function propsChangedCallback() {\n        var _this2 = this;\n\n        if (this.rendererCallback) {\n          this.rendererCallback(this.renderRoot, function () {\n            return _this2.renderCallback && _this2.renderCallback(_this2);\n          });\n        }\n\n        if (this.renderedCallback) {\n          this.renderedCallback();\n        }\n      }\n    }, {\n      key: 'renderRoot',\n      get: function get() {\n        return this._shadowRoot || (this._shadowRoot = this.shadowRoot || attachShadow(this));\n      }\n    }]);\n\n    return _class2;\n  }(Base);\n};\n\nvar suffix = 0;\n\nfunction formatName(prefix, suffix) {\n  prefix = prefix || \"element\";\n  return (prefix.indexOf(\"-\") === -1 ? \"x-\" + prefix : prefix) + (suffix ? \"-\" + suffix : \"\");\n}\n\nfunction generateName(Ctor) {\n  var registry = customElements;\n  var prefix = dashCase(Ctor.name);\n  while (registry.get(formatName(prefix, suffix))) {\n    suffix++;\n  }\n  return formatName(prefix, suffix++);\n}\n\nvar _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits$3(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar withUnique = function withUnique() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return function (_Base) {\n    _inherits$3(_class2, _Base);\n\n    function _class2() {\n      _classCallCheck$4(this, _class2);\n\n      return _possibleConstructorReturn$3(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));\n    }\n\n    _createClass$4(_class2, null, [{\n      key: 'is',\n      get: function get() {\n        return this._is || (this._is = generateName(this));\n      },\n      set: function set(is) {\n        this._is = is;\n      }\n    }]);\n\n    return _class2;\n  }(Base);\n};\n\nvar withComponent = function withComponent(Base) {\n  return withChildren(withProps(withRenderer(withUnique(Base || HTMLElement))));\n};\n\nexports.define = define;\nexports.emit = emit;\nexports.link = link;\nexports.withChildren = withChildren;\nexports.withComponent = withComponent;\nexports.prop = prop;\nexports.withProps = withProps;\nexports.props = props;\nexports.withRenderer = withRenderer;\nexports.withUnique = withUnique;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs/umd/index.js\n// module id = 1\n// module chunks = 0 1","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('preact')) :\n\ttypeof define === 'function' && define.amd ? define(['preact'], factory) :\n\t(global.skateRendererPreact = factory(global.Preact));\n}(this, (function (preact) { 'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/** @jsx h */\n\nvar index = (function () {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return function (_Base) {\n    _inherits(_class, _Base);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    _createClass(_class, [{\n      key: 'rendererCallback',\n      value: function rendererCallback(renderRoot, renderCallback) {\n        this._preactDom = preact.render(renderCallback(), renderRoot, this._preactDom || renderRoot.children[0]);\n      }\n    }, {\n      key: 'props',\n      get: function get() {\n        // We override props so that we can satisfy most use\n        // cases for children by using a slot.\n        return _extends({}, _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'props', this), { children: preact.h('slot', null) });\n      }\n    }]);\n\n    return _class;\n  }(Base);\n});\n\nreturn index;\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@skatejs/renderer-preact/umd/index.js\n// module id = 2\n// module chunks = 0 1","!function() {\n    'use strict';\n    function VNode() {}\n    function h(nodeName, attributes) {\n        var lastSimple, child, simple, i, children = EMPTY_CHILDREN;\n        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);\n        if (attributes && null != attributes.children) {\n            if (!stack.length) stack.push(attributes.children);\n            delete attributes.children;\n        }\n        while (stack.length) if ((child = stack.pop()) && void 0 !== child.pop) for (i = child.length; i--; ) stack.push(child[i]); else {\n            if ('boolean' == typeof child) child = null;\n            if (simple = 'function' != typeof nodeName) if (null == child) child = ''; else if ('number' == typeof child) child = String(child); else if ('string' != typeof child) simple = !1;\n            if (simple && lastSimple) children[children.length - 1] += child; else if (children === EMPTY_CHILDREN) children = [ child ]; else children.push(child);\n            lastSimple = simple;\n        }\n        var p = new VNode();\n        p.nodeName = nodeName;\n        p.children = children;\n        p.attributes = null == attributes ? void 0 : attributes;\n        p.key = null == attributes ? void 0 : attributes.key;\n        if (void 0 !== options.vnode) options.vnode(p);\n        return p;\n    }\n    function extend(obj, props) {\n        for (var i in props) obj[i] = props[i];\n        return obj;\n    }\n    function cloneElement(vnode, props) {\n        return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n    }\n    function enqueueRender(component) {\n        if (!component.__d && (component.__d = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);\n    }\n    function rerender() {\n        var p, list = items;\n        items = [];\n        while (p = list.pop()) if (p.__d) renderComponent(p);\n    }\n    function isSameNodeType(node, vnode, hydrating) {\n        if ('string' == typeof vnode || 'number' == typeof vnode) return void 0 !== node.splitText;\n        if ('string' == typeof vnode.nodeName) return !node._componentConstructor && isNamedNode(node, vnode.nodeName); else return hydrating || node._componentConstructor === vnode.nodeName;\n    }\n    function isNamedNode(node, nodeName) {\n        return node.__n === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n    }\n    function getNodeProps(vnode) {\n        var props = extend({}, vnode.attributes);\n        props.children = vnode.children;\n        var defaultProps = vnode.nodeName.defaultProps;\n        if (void 0 !== defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];\n        return props;\n    }\n    function createNode(nodeName, isSvg) {\n        var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n        node.__n = nodeName;\n        return node;\n    }\n    function removeNode(node) {\n        var parentNode = node.parentNode;\n        if (parentNode) parentNode.removeChild(node);\n    }\n    function setAccessor(node, name, old, value, isSvg) {\n        if ('className' === name) name = 'class';\n        if ('key' === name) ; else if ('ref' === name) {\n            if (old) old(null);\n            if (value) value(node);\n        } else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n            if (!value || 'string' == typeof value || 'string' == typeof old) node.style.cssText = value || '';\n            if (value && 'object' == typeof value) {\n                if ('string' != typeof old) for (var i in old) if (!(i in value)) node.style[i] = '';\n                for (var i in value) node.style[i] = 'number' == typeof value[i] && !1 === IS_NON_DIMENSIONAL.test(i) ? value[i] + 'px' : value[i];\n            }\n        } else if ('dangerouslySetInnerHTML' === name) {\n            if (value) node.innerHTML = value.__html || '';\n        } else if ('o' == name[0] && 'n' == name[1]) {\n            var useCapture = name !== (name = name.replace(/Capture$/, ''));\n            name = name.toLowerCase().substring(2);\n            if (value) {\n                if (!old) node.addEventListener(name, eventProxy, useCapture);\n            } else node.removeEventListener(name, eventProxy, useCapture);\n            (node.__l || (node.__l = {}))[name] = value;\n        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {\n            setProperty(node, name, null == value ? '' : value);\n            if (null == value || !1 === value) node.removeAttribute(name);\n        } else {\n            var ns = isSvg && name !== (name = name.replace(/^xlink\\:?/, ''));\n            if (null == value || !1 === value) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase()); else node.removeAttribute(name); else if ('function' != typeof value) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value); else node.setAttribute(name, value);\n        }\n    }\n    function setProperty(node, name, value) {\n        try {\n            node[name] = value;\n        } catch (e) {}\n    }\n    function eventProxy(e) {\n        return this.__l[e.type](options.event && options.event(e) || e);\n    }\n    function flushMounts() {\n        var c;\n        while (c = mounts.pop()) {\n            if (options.afterMount) options.afterMount(c);\n            if (c.componentDidMount) c.componentDidMount();\n        }\n    }\n    function diff(dom, vnode, context, mountAll, parent, componentRoot) {\n        if (!diffLevel++) {\n            isSvgMode = null != parent && void 0 !== parent.ownerSVGElement;\n            hydrating = null != dom && !('__preactattr_' in dom);\n        }\n        var ret = idiff(dom, vnode, context, mountAll, componentRoot);\n        if (parent && ret.parentNode !== parent) parent.appendChild(ret);\n        if (!--diffLevel) {\n            hydrating = !1;\n            if (!componentRoot) flushMounts();\n        }\n        return ret;\n    }\n    function idiff(dom, vnode, context, mountAll, componentRoot) {\n        var out = dom, prevSvgMode = isSvgMode;\n        if (null == vnode || 'boolean' == typeof vnode) vnode = '';\n        if ('string' == typeof vnode || 'number' == typeof vnode) {\n            if (dom && void 0 !== dom.splitText && dom.parentNode && (!dom._component || componentRoot)) {\n                if (dom.nodeValue != vnode) dom.nodeValue = vnode;\n            } else {\n                out = document.createTextNode(vnode);\n                if (dom) {\n                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n                    recollectNodeTree(dom, !0);\n                }\n            }\n            out.__preactattr_ = !0;\n            return out;\n        }\n        var vnodeName = vnode.nodeName;\n        if ('function' == typeof vnodeName) return buildComponentFromVNode(dom, vnode, context, mountAll);\n        isSvgMode = 'svg' === vnodeName ? !0 : 'foreignObject' === vnodeName ? !1 : isSvgMode;\n        vnodeName = String(vnodeName);\n        if (!dom || !isNamedNode(dom, vnodeName)) {\n            out = createNode(vnodeName, isSvgMode);\n            if (dom) {\n                while (dom.firstChild) out.appendChild(dom.firstChild);\n                if (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n                recollectNodeTree(dom, !0);\n            }\n        }\n        var fc = out.firstChild, props = out.__preactattr_, vchildren = vnode.children;\n        if (null == props) {\n            props = out.__preactattr_ = {};\n            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;\n        }\n        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && null != fc && void 0 !== fc.splitText && null == fc.nextSibling) {\n            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];\n        } else if (vchildren && vchildren.length || null != fc) innerDiffNode(out, vchildren, context, mountAll, hydrating || null != props.dangerouslySetInnerHTML);\n        diffAttributes(out, vnode.attributes, props);\n        isSvgMode = prevSvgMode;\n        return out;\n    }\n    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n        var j, c, f, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0;\n        if (0 !== len) for (var i = 0; i < len; i++) {\n            var _child = originalChildren[i], props = _child.__preactattr_, key = vlen && props ? _child._component ? _child._component.__k : props.key : null;\n            if (null != key) {\n                keyedLen++;\n                keyed[key] = _child;\n            } else if (props || (void 0 !== _child.splitText ? isHydrating ? _child.nodeValue.trim() : !0 : isHydrating)) children[childrenLen++] = _child;\n        }\n        if (0 !== vlen) for (var i = 0; i < vlen; i++) {\n            vchild = vchildren[i];\n            child = null;\n            var key = vchild.key;\n            if (null != key) {\n                if (keyedLen && void 0 !== keyed[key]) {\n                    child = keyed[key];\n                    keyed[key] = void 0;\n                    keyedLen--;\n                }\n            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) if (void 0 !== children[j] && isSameNodeType(c = children[j], vchild, isHydrating)) {\n                child = c;\n                children[j] = void 0;\n                if (j === childrenLen - 1) childrenLen--;\n                if (j === min) min++;\n                break;\n            }\n            child = idiff(child, vchild, context, mountAll);\n            f = originalChildren[i];\n            if (child && child !== dom && child !== f) if (null == f) dom.appendChild(child); else if (child === f.nextSibling) removeNode(f); else dom.insertBefore(child, f);\n        }\n        if (keyedLen) for (var i in keyed) if (void 0 !== keyed[i]) recollectNodeTree(keyed[i], !1);\n        while (min <= childrenLen) if (void 0 !== (child = children[childrenLen--])) recollectNodeTree(child, !1);\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var component = node._component;\n        if (component) unmountComponent(component); else {\n            if (null != node.__preactattr_ && node.__preactattr_.ref) node.__preactattr_.ref(null);\n            if (!1 === unmountOnly || null == node.__preactattr_) removeNode(node);\n            removeChildren(node);\n        }\n    }\n    function removeChildren(node) {\n        node = node.lastChild;\n        while (node) {\n            var next = node.previousSibling;\n            recollectNodeTree(node, !0);\n            node = next;\n        }\n    }\n    function diffAttributes(dom, attrs, old) {\n        var name;\n        for (name in old) if ((!attrs || null == attrs[name]) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);\n        for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name;\n        (components[name] || (components[name] = [])).push(component);\n    }\n    function createComponent(Ctor, props, context) {\n        var inst, list = components[Ctor.name];\n        if (Ctor.prototype && Ctor.prototype.render) {\n            inst = new Ctor(props, context);\n            Component.call(inst, props, context);\n        } else {\n            inst = new Component(props, context);\n            inst.constructor = Ctor;\n            inst.render = doRender;\n        }\n        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n            inst.__b = list[i].__b;\n            list.splice(i, 1);\n            break;\n        }\n        return inst;\n    }\n    function doRender(props, state, context) {\n        return this.constructor(props, context);\n    }\n    function setComponentProps(component, props, opts, context, mountAll) {\n        if (!component.__x) {\n            component.__x = !0;\n            if (component.__r = props.ref) delete props.ref;\n            if (component.__k = props.key) delete props.key;\n            if (!component.base || mountAll) {\n                if (component.componentWillMount) component.componentWillMount();\n            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n            if (context && context !== component.context) {\n                if (!component.__c) component.__c = component.context;\n                component.context = context;\n            }\n            if (!component.__p) component.__p = component.props;\n            component.props = props;\n            component.__x = !1;\n            if (0 !== opts) if (1 === opts || !1 !== options.syncComponentUpdates || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);\n            if (component.__r) component.__r(component);\n        }\n    }\n    function renderComponent(component, opts, mountAll, isChild) {\n        if (!component.__x) {\n            var rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.__p || props, previousState = component.__s || state, previousContext = component.__c || context, isUpdate = component.base, nextBase = component.__b, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = !1;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (2 !== opts && component.shouldComponentUpdate && !1 === component.shouldComponentUpdate(props, state, context)) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.__p = component.__s = component.__c = component.__b = null;\n            component.__d = !1;\n            if (!skip) {\n                rendered = component.render(props, state, context);\n                if (component.getChildContext) context = extend(extend({}, context), component.getChildContext());\n                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n                if ('function' == typeof childComponent) {\n                    var childProps = getNodeProps(rendered);\n                    inst = initialChildComponent;\n                    if (inst && inst.constructor === childComponent && childProps.key == inst.__k) setComponentProps(inst, childProps, 1, context, !1); else {\n                        toUnmount = inst;\n                        component._component = inst = createComponent(childComponent, childProps, context);\n                        inst.__b = inst.__b || nextBase;\n                        inst.__u = component;\n                        setComponentProps(inst, childProps, 0, context, !1);\n                        renderComponent(inst, 1, mountAll, !0);\n                    }\n                    base = inst.base;\n                } else {\n                    cbase = initialBase;\n                    toUnmount = initialChildComponent;\n                    if (toUnmount) cbase = component._component = null;\n                    if (initialBase || 1 === opts) {\n                        if (cbase) cbase._component = null;\n                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);\n                    }\n                }\n                if (initialBase && base !== initialBase && inst !== initialChildComponent) {\n                    var baseParent = initialBase.parentNode;\n                    if (baseParent && base !== baseParent) {\n                        baseParent.replaceChild(base, initialBase);\n                        if (!toUnmount) {\n                            initialBase._component = null;\n                            recollectNodeTree(initialBase, !1);\n                        }\n                    }\n                }\n                if (toUnmount) unmountComponent(toUnmount);\n                component.base = base;\n                if (base && !isChild) {\n                    var componentRef = component, t = component;\n                    while (t = t.__u) (componentRef = t).base = base;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n            }\n            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {\n                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n                if (options.afterUpdate) options.afterUpdate(component);\n            }\n            if (null != component.__h) while (component.__h.length) component.__h.pop().call(component);\n            if (!diffLevel && !isChild) flushMounts();\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n        while (c && !isOwner && (c = c.__u)) isOwner = c.constructor === vnode.nodeName;\n        if (c && isOwner && (!mountAll || c._component)) {\n            setComponentProps(c, props, 3, context, mountAll);\n            dom = c.base;\n        } else {\n            if (originalComponent && !isDirectOwner) {\n                unmountComponent(originalComponent);\n                dom = oldDom = null;\n            }\n            c = createComponent(vnode.nodeName, props, context);\n            if (dom && !c.__b) {\n                c.__b = dom;\n                oldDom = null;\n            }\n            setComponentProps(c, props, 1, context, mountAll);\n            dom = c.base;\n            if (oldDom && dom !== oldDom) {\n                oldDom._component = null;\n                recollectNodeTree(oldDom, !1);\n            }\n        }\n        return dom;\n    }\n    function unmountComponent(component) {\n        if (options.beforeUnmount) options.beforeUnmount(component);\n        var base = component.base;\n        component.__x = !0;\n        if (component.componentWillUnmount) component.componentWillUnmount();\n        component.base = null;\n        var inner = component._component;\n        if (inner) unmountComponent(inner); else if (base) {\n            if (base.__preactattr_ && base.__preactattr_.ref) base.__preactattr_.ref(null);\n            component.__b = base;\n            removeNode(base);\n            collectComponent(component);\n            removeChildren(base);\n        }\n        if (component.__r) component.__r(null);\n    }\n    function Component(props, context) {\n        this.__d = !0;\n        this.context = context;\n        this.props = props;\n        this.state = this.state || {};\n    }\n    function render(vnode, parent, merge) {\n        return diff(merge, vnode, {}, !1, parent, !1);\n    }\n    var options = {};\n    var stack = [];\n    var EMPTY_CHILDREN = [];\n    var defer = 'function' == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n    var items = [];\n    var mounts = [];\n    var diffLevel = 0;\n    var isSvgMode = !1;\n    var hydrating = !1;\n    var components = {};\n    extend(Component.prototype, {\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.__s) this.__s = extend({}, s);\n            extend(s, 'function' == typeof state ? state(s, this.props) : state);\n            if (callback) (this.__h = this.__h || []).push(callback);\n            enqueueRender(this);\n        },\n        forceUpdate: function(callback) {\n            if (callback) (this.__h = this.__h || []).push(callback);\n            renderComponent(this, 2);\n        },\n        render: function() {}\n    });\n    var preact = {\n        h: h,\n        createElement: h,\n        cloneElement: cloneElement,\n        Component: Component,\n        render: render,\n        rerender: rerender,\n        options: options\n    };\n    if ('undefined' != typeof module) module.exports = preact; else self.preact = preact;\n}();\n//# sourceMappingURL=preact.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/preact/dist/preact.js\n// module id = 3\n// module chunks = 0 1"],"sourceRoot":""}